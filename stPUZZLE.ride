{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let VERSION = "stPUZZLE-1.5.0"

let sentinels = [
  Address(base58'3PMcMiMEs6w56NRGacksXtFG5zS7doE9fpL'),
  Address(base58'3PMKAL4cd77onkYuuU35115Wov1sLMEcFsv'),
  Address(base58'3P8auNWJkxxByyJtwErFXaxiXcGM45qQ1hA'),
  Address(base58'3P8qVX189qpoTJZQQQdKS9endHK5sxWsvrd'),
  Address(base58'3P9xX849YJXg7C87v82cDyDy5VhKiPJpHo8')
]

let Scale8 = 100000000
let Scale6 = 1000000
let Fee = 100000 # in Scale8

let puzzleIdStr = "HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS"
let puzzleId = base58'HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS'
let stakingAddress = Address(base58'3PFTbywqxtFfukX3HyT881g4iW5K4QL3FAS')
let maxLPCap = getInteger("setup_maxLPCap").valueOrElse(2000 * Scale8)

func getAssetString(assetId: ByteVector|Unit) = {
  match assetId {
    case b:ByteVector => b.toBase58String()
    case _ => "WAVES"
  }
}

func getAssetBytes(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {unit} else {assetIdStr.fromBase58String()}
}

func getBalance(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {wavesBalance(this).available} else {assetBalance(this, assetIdStr.fromBase58String())}
}

## PUZZLE STAKING FUNCTIONS

func getStakedBalance() = {
  getInteger(stakingAddress, this.toString()+"_staked").valueOrElse(0)
}

func stake(amount: Int) = {
  strict inv = invoke(stakingAddress, "stake", [], [AttachedPayment(puzzleId, amount)])
  inv
}

func stakeAll() = {
  strict inv = invoke(stakingAddress, "stake", [], [AttachedPayment(puzzleId, getBalance(puzzleIdStr))])
  inv
}

func unstake(amount: Int) = {
  strict inv = invoke(stakingAddress, "unStake", [amount], [])
  inv
}

func claim() = {
  strict inv = invoke(stakingAddress, "claimReward", [], [])
  inv
}

func burn(amount: Int) = {
  let toBurn = if amount > 10*Scale8 then 10*Scale8 else amount
  Burn(puzzleId, toBurn)
}

## LP FUNCTIONS

func getLPQuantity() = {
  assetInfo(getStringValue("setup_lpId").fromBase58String()).value().quantity
}

func getLPContractPrice(changedAmount: Int) = {
  strict claimResult = claim()
  strict treasury = assetBalance(this, puzzleId) + getStakedBalance() + changedAmount

  let quant = getLPQuantity()
  if (quant == 0) then Scale8 else fraction(treasury, Scale8, quant)
}

func getStatsEntry () = {
  let assets = split(getStringValue("setup_assets"), ",")
  StringEntry("stats_" + toString(height), toString(getLPQuantity()) + "__" + toString(getBalance(value(assets[0]))) + "__" + toString(getStakedBalance()))
}

## CALLABLES

@Callable(i)
func init() = {
  if (i.caller != this) then {throw("available for self-invoke only")}
  else {
    let lp = Issue("PZL.", "Staked PUZZLE with autocompounded yield. For more details check puzzle.network", 0, 8, true)
    let lpId = lp.calculateAssetId()

    [
      lp,
      StringEntry("setup_lpId", lpId.toBase58String()),
      StringEntry("setup_assets", puzzleIdStr)]
  }
}

@Callable(i)
func doRefPayment(ref: String, feeAmount: Int) = {
  if (ref == "") then {
    [
      burn(feeAmount)
    ]
  } else {
    let refAddress = getString("ref_"+ref+"_data").valueOrErrorMessage("ref " + ref + " not found").split("__")[0].value().addressFromStringValue()
    let protocolPart = fraction(feeAmount, 1, 2)
    [
      burn(protocolPart),
      ScriptTransfer(refAddress, feeAmount-protocolPart, puzzleId)
    ]
  }
}

@Callable(i)
func mintLP(ref: String) = {
  let assetId = i.payments[0].assetId
  let amount = i.payments[0].amount
  let feeAmount = fraction(amount, Fee, Scale8, CEILING)
  strict feeInv = invoke(this, "doRefPayment", [ref, feeAmount], [])

  let cleanAmount = amount - feeAmount

  let quantity = getLPQuantity()
  strict toMint = fraction(cleanAmount, Scale8, getLPContractPrice(-cleanAmount), DOWN)

  if (getStringValue("setup_assets").indexOf(assetId.getAssetString()) == unit) then {throw("wrong asset attached")}
  else if (getString("setup_isPaused").valueOrElse("") != "") then {throw("contract is paused")}
  else if ((quantity + toMint) > maxLPCap) then {throw("LP cap reached")}
  else {
    
    let lpId = getStringValue("setup_lpId").fromBase58String()
    let reissue = Reissue(lpId, toMint, true)

    strict inv = stakeAll()

    [
      reissue,
      ScriptTransfer(i.caller, toMint, lpId)
    ]

  }
}

@Callable(i)
func redeemLP() = {
  let lpId = getString("setup_lpId").valueOrElse("").fromBase58String()
  let attachedAssetId = i.payments[0].assetId
  let amount = i.payments[0].amount

  let treasuryAssets = getStringValue("setup_assets").split(",")
  let assetToReturn = treasuryAssets[0].getAssetBytes()
  strict amountToReturn = fraction(amount, getLPContractPrice(0), Scale8, DOWN)

  if (attachedAssetId != lpId) then {throw("wrong asset attached")}
  else if (getString("setup_isPaused").valueOrElse("") != "") then {throw("contract is paused")}
  else {
    strict inv = unstake(amountToReturn)

    [
      Burn(lpId, amount),
      ScriptTransfer(i.caller, amountToReturn, assetToReturn),
      getStatsEntry()
    ]
  }
}

## ADMIN FUNCTIONS

@Callable(i)
func addRef(domain: String, name: String, address: String, pic: String) = {
  if (i.caller != this && sentinels.indexOf(i.caller) == unit) then {throw("admin only")}
  else {
    [
      StringEntry("ref_"+domain+"_data", address + "__" + name + "__" + pic),
      StringEntry("ref_domains", getString("ref_domains").valueOrElse("") + domain + ",")
    ]
  }
}

@Callable(i)
func updateString(key: String, val: String) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    [
      StringEntry(key, val)
    ]
  }
}

@Callable(i)
func updateInt(key: String, val: Int) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    [
      IntegerEntry(key, val)
    ]
  }
}

@Callable(i)
func getLPPrice(debug: Boolean) = {
  strict res = getLPContractPrice(0)
  if (debug) then { throw(res.toString()) } else { ([], res)}
}


## VERIFIER

@Callable(i)
func initNewMaster(master: String) = {
  let addressOK = match addressFromString(master){
    case a: Address => true
    case _ => false
  }
  
  if(!addressOK) then {
    throw("incorrect address " + master)
  } else 
  if (i.caller != this) then {
    throw("available for self call only")
  } else {
    [
      StringEntry("verifier_master", master)
    ]
  }
}

@Callable(i)
func requestNewMaster(newMaster: String) = {
  let addressOK = match addressFromString(newMaster){
    case a: Address => true
    case _ => false
  }

  if(!addressOK) then {
    throw("incorrect address " + newMaster)
  } else if (sentinels.indexOf(i.caller) == unit) then {
    throw("whitelist only")
  } else {
    [
      StringEntry("verifier_newMaster", newMaster),
      IntegerEntry("verifier_newMasterEligibleAfter", height+10000)
    ]
  }
}

@Callable(i)
func activateNewMaster() = {
  let eligibleHeight = getIntegerValue(this, "verifier_newMasterEligibleAfter")
  let newMaster = getStringValue(this, "verifier_newMaster")

  if (sentinels.indexOf(i.caller) == unit) then {
    throw("whitelist only")
  } else if (eligibleHeight > height) then {
    throw("new master cannot be activated yet")
  } else {
    [
      DeleteEntry("verifier_newMaster"),
      DeleteEntry("verifier_newMasterEligibleAfter"),
      StringEntry("verifier_master", newMaster)
    ]
  }
}

@Verifier(tx)
func verify() = {
  let masterAddress = getString("verifier_master")
  let approvedByMaster = match masterAddress {
    case x: String => match getInteger(x.addressFromStringValue(), "approvedTx_"+tx.id.toBase58String()) {
      case y: Int => y
      case _ => 0
    }
    case _ => 1
  }
  sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey) && (approvedByMaster > 0)
}
